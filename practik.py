# В этом уроке мы займёмся созданием надстройки для программы,
# которая позволит перенести алгоритмы сортировки в отдельный модуль.
# Несмотря на то, что алгоритмы сортировки уже существуют, представим, что мы их разработали,
# и наша задача — подготовить код для использования другими участниками проекта.
#
# Чтобы облегчить распространение и повторное использование кода,
# логично вынести алгоритмы в отдельный файл.
# Это позволит импортировать готовые функции в любой проект, минимизируя дублирование кода.
#
# Мы уже подготовили рабочую среду: создали отдельную директорию,
# внутри которой находится файл с именем "sortfunc".
# Этот файл станет самостоятельным модулем,
#  который в будущем можно будет передавать коллегам и подключать к другим проектам (Рис.1).

import this

# import this - Импорт «Дзена Python»
#
# В условиях неопределённости откажитесь от соблазна гадать.
# Должен быть один — и желательно только один — очевидный способ сделать это.
# Хотя этот способ может быть неочевидным на первый взгляд, если только вы не голландец.
# Лучше сейчас, чем никогда.
# Хотя «никогда» часто лучше, чем «прямо сейчас».
# Если реализацию трудно объяснить, это плохая идея.
# Если реализацию легко объяснить, это может быть хорошей идеей.
# Пространства имён — это чертовски отличная идея, давайте использовать их чаще!
#
# Язык программирования Python активно использует концепцию пространства имён,
#  что становится особенно очевидным при работе с классами в будущем.
#  В текущем примере рассматривается глобальное пространство имён файла «namespaces»,
#  в котором могут находиться переменные, функции и имена модулей.

# Для демонстрации этого принципа можно импортировать модуль «math»,
# аналогично предыдущим примерам (Рис.5).
# После выполнения импорта модуль становится доступным,
# и его атрибуты можно использовать,
# применяя нотацию через точку.
# Такой подход схож с импортом модулей из пакетов,
# где указывается путь к нужному файлу.
# Это подчёркивает гибкость работы с пространствами имён в Python.

import math

#В качестве примера рассмотрим модуль «math».
# Используя его, можно вычислить квадратный корень переменной «a».
# Выполнение соответствующего выражения возвращает значение, равное 2,23 (Рис.6).
#
# Этот процесс включает обращение к модулю «math»,
#  вызов его атрибута — функции «sqrt», и передачу ей переменной из глобального пространства имён.
#  Такой подход демонстрирует взаимодействие между разными уровнями пространств имён в Python.

a=5
print(math.sqrt(a))
print(globals())
#  {'__name__': '__main__', '__doc__': None, '__package__': None,
#       '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x000001F10C494380>,
#       '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>,
#       '__file__': 'G:\\pyton\\Namespace\\practik.py', '__cached__': None,
#       'this': <module 'this' from 'C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\this.py'>,
#  !!!  'math': <module 'math' (built-in)>,
#        'a': 5}
# В полученном словаре глобального пространства имён действительно присутствует ключ «math» (Рис.9).
# Это имя используется для обращения к соответствующему модулю, позволяя вызывать его функции и атрибуты.
# Значением имени «math» в глобальном пространстве имён является объект типа «module math» (Рис.10).
# Это указывает на то, что модуль был успешно импортирован и привязан к указанному имени.
# Теперь к его функциям и атрибутам можно обращаться с использованием этой ссылки.
# В глобальном пространстве имён также присутствует имя «a», связанное с объектом типа «int» со значением 5 (Рис.11).
# Это означает, что переменная «a» была создана и хранит целое число,
# к которому можно обращаться по указанному имени в текущем пространстве имён.

# При использовании конструкции "from math import *" все публичные атрибуты модуля «math»
# добавляются в глобальное пространство имён текущего файла «namespaces».
# Это можно проверить, вызвав функцию globals,
# которая покажет значительное увеличение числа доступных объектов (Рис.12, 13, 14).
#
# Таким образом, происходит импорт всех имён из пространства имён модуля «math»
# в глобальное пространство текущего модуля.
# Это увеличивает количество доступных атрибутов, но может привести к конфликтам имён,
# если импортированные элементы совпадают с уже существующими.
# Поэтому такой подход следует применять с осторожностью.

from math import *
print(globals())
# {'__name__': '__main__', '__doc__': None, '__package__': None,
# '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x000002279EAC4380>,
# '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>,
# '__file__': 'G:\\pyton\\Namespace\\practik.py', '__cached__': None,
# 'this': <module 'this' from 'C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\this.py'>,
# 'math': <module 'math' (built-in)>, 'a': 5,
#
# 'acos': <built-in function acos>, 'acosh': <built-in function acosh>, 'asin': <built-in function asin>,
# 'asinh': <built-in function asinh>, 'atan': <built-in function atan>, 'atan2': <built-in function atan2>,
# 'atanh': <built-in function atanh>, 'cbrt': <built-in function cbrt>, 'ceil': <built-in function ceil>,
# 'copysign': <built-in function copysign>, 'cos': <built-in function cos>, 'cosh': <built-in function cosh>,
# 'degrees': <built-in function degrees>, 'dist': <built-in function dist>, 'erf': <built-in function erf>,
# 'erfc': <built-in function erfc>, 'exp': <built-in function exp>, 'exp2': <built-in function exp2>,
# 'expm1': <built-in function expm1>, 'fabs': <built-in function fabs>,
# 'factorial': <built-in function factorial>, 'floor': <built-in function floor>,
# 'fmod': <built-in function fmod>, 'frexp': <built-in function frexp>,
# 'fsum': <built-in function fsum>, 'gamma': <built-in function gamma>,
# 'gcd': <built-in function gcd>, 'hypot': <built-in function hypot>,
# 'isclose': <built-in function isclose>, 'isfinite': <built-in function isfinite>,
# 'isinf': <built-in function isinf>, 'isnan': <built-in function isnan>,
# 'isqrt': <built-in function isqrt>, 'lcm': <built-in function lcm>,
# 'ldexp': <built-in function ldexp>, 'lgamma': <built-in function lgamma>,
# 'log': <built-in function log>, 'log1p': <built-in function log1p>,
# 'log10': <built-in function log10>, 'log2': <built-in function log2>, 'modf': <built-in function modf>,
# 'pow': <built-in function pow>, 'radians': <built-in function radians>,
# 'remainder': <built-in function remainder>, 'sin': <built-in function sin>,
# 'sinh': <built-in function sinh>, 'sqrt': <built-in function sqrt>,
# 'tan': <built-in function tan>, 'tanh': <built-in function tanh>,
# 'sumprod': <built-in function sumprod>, 'trunc': <built-in function trunc>,
# 'prod': <built-in function prod>, 'perm': <built-in function perm>,
# 'comb': <built-in function comb>, 'nextafter': <built-in function nextafter>,
# 'ulp': <built-in function ulp>, 'pi': 3.141592653589793, 'e': 2.718281828459045,
# 'tau': 6.283185307179586, 'inf': inf, 'nan': nan}

# Действительно, наличие локальных пространств имён открывает дополнительные возможности управления переменными.
# Чтобы проиллюстрировать это, вернём импорт модуля с использованием команды "import math",
# чтобы избежать перенасыщения глобального пространства имён.
#
# Создадим функцию, вычисляющую квадрат переданного значения.
# Внутри этой функции определим локальную переменную «a»,
# присвоив ей результат операции возведения в квадрат аргумента «x» с использованием выражения
# "a = x ** 2". Затем функция будет возвращать значение этой переменной «a» (Рис.15).


import math


def square(x):
    a = x ** 2
    return a


a = 5
b=square(2)
print(b)
print(globals())

# {'__name__': '__main__', '__doc__': None,
# '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x000001FE70164380>,
# '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>,
# '__file__': 'G:\\pyton\\Namespace\\practik.py', '__cached__': None,
# 'this': <module 'this' from 'C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\this.py'>,
# 'math': <module 'math' (built-in)>, 'a': 5,
# .
# .
#  'square': <function square at 0x00000260FE7C9D00>, 'b': 4}

'''Внутри функции «square» создаётся локальное пространство имён,
 в котором определяется переменная «a», равная квадрату переданного аргумента. 
 При вызове square(2) аргумент x принимает значение 2. 
 Переменная a внутри функции получает значение 2 ** 2, то есть 4.
Затем создаётся глобальная переменная «b», которой присваивается результат вызова функции square(2).
 После этого её значение выводится на экран, и отображается число 4, поскольку это квадрат числа 2 (Рис.18).
 
 Если внутри функции «square» вызвать функцию globals(), она вернёт словарь глобального пространства имён (Рис.19).
  Однако локальные переменные функции, такие как «a»,
   в этот словарь не попадут, поскольку globals() отображает только глобальные объекты.

'''


def square(x):
    a = x ** 2
    print()
    print("locals-- ",locals())
    print("globals-- ",globals())
    return a


a = 5
b = square(2)
print(b)
'''В Python существует три основных пространства имён: глобальное, локальное и встроенное.

1) Глобальное пространство имён содержит имена, определённые на уровне модуля. 
Переменная "a", равная 5, находилась именно в этом пространстве до вызова функции.

2) Локальное пространство имён создаётся при вызове функции. 
Переменные, объявленные внутри функции, существуют только в её области видимости.

3) Встроенное пространство имён включает стандартные функции и объекты Python, 
такие как "prin"t, "len", "sum" и т.д.

Порядок поиска имён (LEGB):

L — Local (Локальное)
E — Enclosing (Закрывающее, для вложенных функций)
G — Global (Глобальное)
B — Built-in (Встроенное)

Если внутри функции написать "a ** 2", Python сначала будет искать переменную "a" в локальном пространстве.
Если её там нет, он проверит глобальное пространство, а затем встроенные имена. 
Поскольку глобальная переменная "a" была доступна, операция возведения в квадрат сработала успешно, 
даже без её объявления в локальном пространстве (Рис.27).'''
# Переменная "a" сначала ищется внутри функции "inner()".
# Так как её там нет, интерпретатор проверяет функцию "outer()", где "a" = 5.
# Глобальная "a" = 10 используется только в том случае,
# если переменная не найдена ни в одном из внутренних пространств.
# Если "a" не была бы найдена ни в одном из предыдущих уровней,
# Python искал бы её среди встроенных объектов.

def square(x):
    d = x ** 2

    def even(x):
        d = x * 2
        if d % 2 == 0:
            print('Четное')
        else:
            print('Нечетное')

    return d

# Этапы поиска переменной:
#
# 1) Локальная область видимости (Local): переменная сначала ищется внутри функции "even".
# Если она найдена, поиск прекращается.
#
# 2) Объемлющая область видимости (Enclosing): если переменной нет в "even",
# интерпретатор ищет её в объемлющей функции, которая находится уровнем выше.
# Это происходит, если even вложена в другую функцию.
#
# 3) Глобальная область видимости (Global): если переменная не найдена в объемлющей функции,
# Python проверяет глобальную область видимости, где находятся переменные, определённые на уровне модуля.
#
# 4) Встроенная область видимости (Built-in): если переменной нет и в глобальной области,
# интерпретатор обращается к встроенной области видимости,
# содержащей стандартные функции и объекты Python, такие как "print", "len", "int" и т.д.

